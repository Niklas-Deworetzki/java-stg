
\chapter{Ergebnisse}\label{chap:ergebnisse}

Mit den Regeln aus Kapitel~\ref{chap:implementierung} und den vorgestellten Sprachkonstrukten aus Kapitel~\ref{chap:stg} ist es nun möglich, nicht-strikte Programme geschrieben in der \gls{stg}-Sprache auszuwerten.
Die Ausführung erfolgt dabei entsprechend der Spezifikation, ermöglicht die Integration von primitiven Java-Operationen und arbeitet korrekt auf allen unterstützten Werten, von primitiven Zahlen, über einfache Datentypen bis hin zu Funktionen und verzögert ausgewerteten oder sogar endlosen Datenstrukturen.

Die vollständige Implementierung in Java ist auf GitHub verfügbar\footnote{\url{https://github.com/Niklas-Deworetzki/java-stg}}.
Im selben Projekt befinden sich neben den verschiedenen Quelldateien auch eine Prelude, die vor der Ausführung von \gls{stg}-Programmen geladen werden kann, um einige häufig verwendete Funktionen bereitzustellen.

Das Projekt erfüllt dabei die Ansprüche und Ziele, die zu Beginn gesetzt wurden und präsentiert eine einfache aber funktionstüchtige Implementierung einer virtuellen \gls{stg}-Maschine.
Zusätzlich werden durch die Prelude die Eigenschaften der \gls{stg}-Sprache als Kernsprache hervorgehoben und exemplarisch gezeigt, wie höhere Abstraktionsebenen in die maschinennahe Sprache eingeführt werden können.
Das Hauptziel, die Semantik der \gls{stg}-Maschine korrekt abzubilden wurde erreicht.
Darüber hinaus werden einige der Erweiterungen, die von der \gls{stg} vorgestellt werden, implementiert.
Neben der \textit{spineless} Darstellung eines Programms, die durch Verwendung der \gls{stg} \enquote{geschenkt} ist, wird auch die \textit{tagless} Darstellung implementiert.
Die verschiedenen Maschinenzustände werden nicht durch explizite Tags unterschieden, sondern semantische Aktionen polymorph zur Laufzeit ausgewählt.
Zudem werden auch Optimierungen, wie etwa das Aktualisieren von ausgewerteten Closures, unterstützt.

\section{Wichtige Erweiterungen}

Obwohl die Kernfunktionalität der \gls{stg} implementiert ist und auch die besonderen Eigenschaften der Maschine unterstützt werden, existieren einige Erweiterungen und diskutierte Optimierungen aus \cn{stg}, die nicht implementiert sind.

Viele der möglichen Erweiterungen, die sich in die \gls{stg}-Maschine einbauen lassen, sind in erster Linie dazu gedacht, die Programmierung zu erleichtern oder den produktiven Betrieb zu ermöglichen.
So kann beispielsweise ein Foreign Function Interface bereitgestellt werden, um mit existierenden Bibliotheken anderer Programmiersprachen zu interagieren\cn{}.
Die Implementierung dieser Schnittstelle ist dabei ähnlich wie die Integration eingebauter, primitiver Funktionen.

Eine weitere hilfreiche Erweiterung baut auf das Aktualisieren von Closures auf.
Wird eine Closure, nachdem sie betreten aber bevor sie vollständig ausgewertet wird, durch einen speziellen Wert gesetzt, lassen sich Fehler zur Laufzeit entdecken.
Ein sogenanntes \textit{Blackhole} lässt sich für eine betretene Closure einsetzen, mit der Eigenschaft, dass das Betreten eines Blackholes einen Fehler wirft.
Ein solcher Fehler wird nur geworfen, wenn während der Auswertung einer Closure, die selbe Closure erneut betreten wird.
Das bedeutet, dass ein Wert von sich selbst abhängig ist und somit nicht berechnet werden kann.

Anstelle eines Blackholes, können aber auch andere besondere Darstellungen für Closures eingesetzt werden.
Beispielsweise ist es möglich, betretene Closures durch Synchronisierungsblöcke.
Dadurch können mehrere Closures gleichzeitig betreten und in unterschiedlichen Threads ausgewertet werden.
Ist die Auswertung abgeschlossen sorgen Synchronisierungsblöcke dafür, dass die verschiedenen Threads wieder zusammenführen.
Auf diese Weise kann unsichtbar für einen Nutzer Parallelisierung implementiert werden.

Die Wohl wichtigste Erweiterung, die zunächst notwendig ist, um die produktive Verwendung der Implementierung überhaupt in Betracht zu ziehen, ist die Implementierung eines Garbage Collectors.
Die Sprachsemantik definiert nur ein Konstrukt für die Speicherallokation.
Eine kontrollierte Speicherfreigabe ist nicht vorgesehen.
Stattdessen gibt es einige Modelle für eine Garbage Collection, die im Hintergrund oder Parallel läuft und sich die Struktur des Graphen zu Nutze macht, um zu entscheiden, welche Closures für die Auswertung relevant sind\cn{}.


\section{Schwachstellen der Implementierung}

Auch wenn sie entsprechend der Beschreibung arbeitet, existieren einige Schwachstellen in der vorgestellten Implementierung.
Diese Beziehen sich hauptsächlich auf die Ausführung und die Nutzerfreundlichkeit der Maschine.

Main wird durch Fehler erkannt.

Kein Debugger, keine vernünftige Ausgabe von Werten.

Trotz Erfahrungsschatz, einige wichtige Felder unberührt.
Wie Maschinencode, wie Speicherlayout und Darstellung, wie Speicherverwaltung.


\section{Einordnung im Vergleich zu existierenden Lösungen}

STG für Graphenausführung wird weiterentwickelt, zudem andere Implementierungen bekannt.
In der aktuellen Form nicht mehr up-to-date. Ausführungsformen optimieren Funktionsanwendungen, Parameterübergabe für häufige Use-Cases\cn{Fast Curry}

Andere Implementierungen in Haskell.
Weniger Imperativ, dafür näher an Domäne der Verwender.
GUI für Debugging und Nachvollziehen, was zur Laufzeit geschieht.

Implementierung STG, produktives System, Optimierungen, Performance, Tooling.
Standard und verwendbar.

Zusammenfassend ist dieses Projekt als Lern- und Spielzeugprojekt zu betrachten.
Der Hauptzweck der Implementierung ist es, innerhalb des Kurses \cn{KAPS} Erfahrungen zu sammeln, neue Berechnungsmodelle zu untersuchen und den Horizont zu erweitern.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Ausarbeitung"
%%% End:
