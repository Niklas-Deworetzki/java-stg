
\chapter{Die STG-Sprache}\label{chap:stg}


Sprache gibt Beschreibung der STG-Maschine an.
Hier ist auch Unterschied zu anderen Maschinensprachen deutlich.
Keine Instruktionen, stattdessen wird Programmgraph als funktionales Program beschrieben.

Funktionale Programmiersprache dennoch mit Einschränkungen verbunden, die Ausdrucksstärke reduzieren.
Ziel ist nicht angenehmes Programmieren sondern Nähe zur Semantik.

Verschiedene Sprachkonzepte werden vorgestellt und informell mit Bedeutung in der Maschine verknüpft.

Überblick mit Grammatik.
Aussehen ähnelt Haskell, wird auch so dargestellt.
Verwendung von Einrückung und Zeilenumbrüchen zur Abgrenzung.
Interessante Anmerkung: Keine Typisierung im Vergleich zu Haskell.

% TODO: Grafik Grammatik der STG Sprache + Anmerkung dass in Anhang LR(1) Grammatik verwendet wird.


\section{Lambda}

Viele Besonderheiten:
Freie Variablen (benötigt zur Berechnung von Speicherbedarf der Closure)
Update-Flag

Ansonsten wir gewohnt:
Parameter
Rumpf


\section{Let-Bindings}

Let und Letrec.
Erstellt immer Lambdas, direkter Kontakt zu lazy.

Bedeutung ist Speichern auf dem Heap (Heap-Allokation)


\section{Anwendungen}

Funktionen, Konstruktoren, Primitive Operationen.
Eta-Expansion nicht wie in Haskell. % TODO: Warum?

Argumente immer Atome: Variablen oder Primitive Zahlen.
Erfordert anlegen auf Heap via Let für komplexe Parameter.
Einschränkung der Ausdrucksstärke (tatsächlich Ausdruck eingeschränkt), dafür jedoch beschränkte Komplexität in Maschine.
Bei Aufruf müssen Parameter nicht untersucht werden: Alle direkt in atomarer Form.


\section{Fallunterscheidungen}

Auswertung nur hier.
Zwingend nötig, da WHNF den Konstruktor ``kennt'', um Alternative zu bestimmen.
Somit wichtiges Konstrukt.

Unterscheidung in Algebraische Alternativen und Primitive Alternativen.

Immer vorhanden: Defaults.
Passt niemand wird ein Fehler geworfen.

\section{Primitive}

Warum sind Primitive direkt in der Sprachbeschreibung enthalten?
Macht Konzept rund, keine Mehraufwand für Maschinenworte.
Erhöht Performance, da keine Lazyness und direkt Maschinenworte.

Einpacken in Lazyness nur mit minimaler Abstraktionsebene.

% TODO: Beispiel für + und - 


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Ausarbeitung"
%%% End:
