@Book{Miller_CommonLanguageInfrastructure,
  author    = {James S. Miller, Susann Ragsdale},
  publisher = {Addison-Wesley},
  title     = {The {C}ommon {L}anguage {I}nfrastructure {A}nnotated {S}tandard},
  year      = {2003},
  isbn      = {0321154932},
  month     = nov,
  ean       = {9780321154934},
  pagetotal = {928},
  url       = {https://www.ebook.de/de/product/3260570/james_s_miller_susann_ragsdale_the_common_language_infrastructure_annotated_standard.html},
}

@Article{Slot_ProblemSpaceInvariance,
  author   = {Slot, Cees and van Emde Boas, Peter},
  journal  = {Information and Computation},
  title    = {The {P}roblem of {S}pace {I}nvariance for {S}equential {M}achines},
  year     = {1988},
  number   = {2},
  pages    = {93-122},
  volume   = {77},
  abstract = {In complexity theory the use of informal estimates can be justified by appealing to the Invariance Thesis which states that all standard models of sequential computing devices are equivalent in the sense that the fundamental complexity classes do not depend on the precise model chosen for their definition. This thesis would require, among others, that a RAM can be simulated by a Turing machine with constant factor overhead in space. We argue that the definition of RAM space, at least in the manner it is traditionally given in the literature, is inadequate for this purpose. The invariance thesis can be validated only in a weak interpretation. The rather complicated simulation which achieves the constant factor space overhead is based on a new method for condensing space and uses perfect hash functions with minimal program size.},
  doi      = {https://doi.org/10.1016/0890-5401(88)90052-1},
}

@Online{Wiki_Haskell,
  author   = {Wikibooks{,} The Free Textbook Project},
  title    = {{H}askell / {L}aziness},
  url      = {https://en.wikibooks.org/w/index.php?title=Haskell/Laziness&oldid=3676028},
  urldate  = {2022-01-05},
  year     = {2020},
  abstract = {Consider the reasons and implications of lazy evaluation. At first glance, we might think that lazy evaluation makes programs more efficient. After all, what can be more efficient than not doing anything? In practice, however, laziness often introduces an overhead that leads programmers to hunt for places where they can make their code more strict. The real benefit of laziness is in making the right things efficient enough. Lazy evaluation allows us to write more simple, elegant code than we could in a strict environment.},
}

@Comment{jabref-meta: databaseType:bibtex;}

@Comment{jabref-entrytype: online: req[author;title;year;url;urldate] opt[language;note]}
