package deworetzik.stg.parse;

import deworetzki.parse.Position;
import java_cup.runtime.*;
import java.util.*;

import deworetzki.stg.syntax.*;
import deworetzki.parse.symbol.*;

parser code {:
/**
 * Creates a new {@link Position} object from given left and right values.
 */
public Position position(int left, int right) {
    return new Position(
            ((deworetzki.stg.parser.Scanner) getScanner()).source,
            left, right);
}

private static <T> List<T> nil() {
    return new LinkedList<>();
}

private static <T> List<T> cons(T head, List<T> tail) {
    tail.add(0, head);
    return tail;
}
:}

terminal TERMINATOR;
terminal LBRA, RBRA;

terminal LET, LETREC, IN;
terminal MATCH, CASE, DEFAULT;
terminal EQ, LAMBDA, SINGLEARROW, DOUBLEARROW;
terminal String VARIABLE, TYPE, PRIMITIVE;

terminal Integer INTLIT;

non terminal Program Program;
non terminal Bind Bind;
non terminal LambdaForm LambdaForm;

non terminal Expression Expression, CaseExpression, LetBinding;
non terminal Application Application;

non terminal Alternatives Alternatives;
non terminal List<Alternative> PrimitiveAlternatives, AlgebraicAlternatives;
non terminal Alternative PrimitiveAlternative, AlgebraicAlternative;
non terminal DefaultAlternative DefaultAlternative;

non terminal Atom Atom;
non terminal Variable Variable;
non terminal Constructor Constructor;
non terminal Literal Literal;

non terminal List<Atom> Atoms;
non terminal List<Bind> Bindings, NonEmptyBindings;
non terminal List<Variable> Variables;

non terminal Boolean AnyLet, LambdaArrow;
non terminal Epsilon;
non terminal Arrow;

start with Program;



// TODO: Warn if double?
Arrow ::= SINGLEARROW | DOUBLEARROW
        ;

LambdaArrow ::= DOUBLEARROW
                                                {: RESULT = false; :}
              | SINGLEARROW
                                                {: RESULT = true; :}
              ;

AnyLet ::= LET
                                                {: RESULT = false; :}
         | LETREC
                                                {: RESULT = true; :}
         ;

Epsilon ::=  ; // Empty symbol



Program ::= Bindings:bindings
                                                {: RESULT = new Program(position(bindingsleft, bindingsright), bindings); :}
          ;

Bind ::= Variable:var EQ:anchor LambdaForm:lambda
                                                {: RESULT = new Bind(position(anchorleft, anchorright), var, lambda); :}
       ;

Bindings ::= NonEmptyBindings:bindings
                                                {: RESULT = bindings; :}
           | Epsilon
                                                {: RESULT = nil(); :}
           ;

NonEmptyBindings ::= Bind:head TERMINATOR NonEmptyBindings:tail
                                                {: RESULT = cons(head, tail); :}
                   | Bind:head
                                                {: RESULT = cons(head, nil()); :}
                   ;

//
//
//

LambdaForm ::= LAMBDA:anchor LBRA Variables:free RBRA Variables:args LambdaArrow:arrow Expression:expr
                                                {: RESULT = new LambdaForm(position(anchorleft, anchorright), free, arrow, args, expr); :}
             | LAMBDA:anchor Variables:args LambdaArrow:arrow Expression:expr
                                                {: RESULT = new LambdaForm(position(anchorleft, anchorright), null, arrow, args, expr); :}
             ;

//
//
//

Expression ::= CaseExpression:expr
                                                {: RESULT = expr; :}
             | LetBinding:expr
                                                {: RESULT = expr; :}
             | Application:expr
                                                {: RESULT = expr; :}
             | Literal:literal
                                                {: RESULT = literal; :}
             ;

LetBinding ::= AnyLet:let Bindings:binds IN Expression:expr
                                                {: RESULT = new LetBinding(position(letleft, letright), let, binds, expr); :}
                ;

CaseExpression ::= MATCH:anchor Expression:expr LBRA Alternatives:alternatives RBRA
                                                {: RESULT = new CaseExpression(position(anchorleft, anchorright), expr, alternatives); :}
                 ;

//
//
//

Application ::= Variable:function Atoms:args
                                                {: RESULT = new FunctionApplication(position(functionleft, functionright), function, args); :}
              | Constructor:constr Atoms:args
                                                {: RESULT = new ConstructorApplication(position(constrleft, constrright), constr, args); :}
              | PRIMITIVE:op Atoms:args
                                                {: RESULT = new PrimitiveApplication(position(opleft, opright), op, args); :}
              ;

//
//
//

Alternatives ::= AlgebraicAlternatives:alts DefaultAlternative:def
                                                {: RESULT = new Alternatives(
                                                    position(headleft, headright), alts, def); :}
               | PrimitiveAlternatives:alts DefaultAlternative:def
                                                {: RESULT = new Alternatives(
                                                    position(headleft, headright), alts, def); :}
               | DefaultAlternative:def
                                                {: RESULT = new Alternatives(position(defleft, defright), nil(), def); :}
               ;

AlgebraicAlternatives ::= AlgebraicAlternative:head TERMINATOR AlgebraicAlternatives:tail
                                                {: RESULT = cons(head, tail); :}
                        | AlgebraicAlternative:head
                                                {: RESULT = cons(head, nil()); :}
                        ;

PrimitiveAlternatives ::= PrimitiveAlternative:head TERMINATOR PrimitiveAlternatives:tail
                                                {: RESULT = cons(head, tail); :}
                        | PrimitiveAlternative:head
                                                {: RESULT = cons(head, nil()); :}
                        ;

AlgebraicAlternative ::= CASE:anchor Constructor:constr Atoms:args Arrow Expression:expr
                                                {: RESULT = new AlgebraicAlternative(position(anchorleft, anchorright), constr, args, expr); :}
                       ;

PrimitiveAlternative ::= CASE:anchor Literal:literal Arrow Expression:expr
                                                {: RESULT = new PrimitiveAlternative(position(anchorleft, anchorright), literal, expr); :}
                       ;

DefaultAlternative ::= CASE:anchor DEFAULT Arrow Expression:expr
                                                                       {: RESULT = new DefaultFallthroughAlternative(position(anchorleft, anchorright), expr); :}
                     | CASE:anchor Variable:binder Arrow Expression:expr
                                                                       {: RESULT = new DefaultBindingAlternative(position(anchorleft, anchorright), binder, expr); :}
                     | Epsilon:anchor
                                                                       {: RESULT = new NoAlternative(position(anchorleft, anchorright)); :}
                     ;

//
//
//

Variables ::= Variable:head Variables:tail
                                                {: RESULT = cons(head, tail); :}
            | Epsilon
                                                {: RESULT = nil(); :}
            ;

Atoms ::= Atom:head Atoms:tail
                                                {: RESULT = cons(head, tail); :}
        | Epsilon
                                                {: RESULT = nil(); :}
        ;

Atom ::= Variable:variable
                                                {: RESULT = variable; :}
       | Literal:literal
                                                {: RESULT = literal; :}
       ;

Variable ::= VARIABLE:variable
                                                {: RESULT = new Variable(position(variableleft, variableright), variable); :}
           ;

Constructor ::= TYPE:type
                                                {: RESULT = new Constructor(position(typeleft, typeright), type); :}
              ;

Literal ::= INTLIT:literal
                                                {: RESULT = new Literal(position(literalleft,literalright), literal); :}
          ;

