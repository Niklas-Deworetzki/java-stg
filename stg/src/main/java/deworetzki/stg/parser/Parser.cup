package deworetzik.stg.parse;

import java_cup.runtime.*;
import java.util.*;

import deworetzki.parse.Position;
import deworetzki.parse.symbol.*;
import deworetzki.stg.syntax.*;

import deworetzki.messages.*;
import deworetzki.stg.Options.Extensions;
import deworetzki.stg.Options;

parser code {:
public Options options;

/**
 * Creates a new {@link Position} object from given left and right values.
 */
public Position position(int left, int right) {
    return new Position(
            ((deworetzki.stg.parser.Scanner) getScanner()).source,
            left, right);
}

private static <T> List<T> nil() {
    return new LinkedList<>();
}

private static <T> List<T> cons(T head, List<T> tail) {
    tail.add(0, head);
    return tail;
}

public boolean isExtensionEnabled(Extensions extension) {
    return options.isExtensionEnabled(extension);
}
:}

terminal LEFT, RIGHT;

terminal LET, LETREC, IN;
terminal MATCH, CASE, DEFAULT;
terminal EQ, LAMBDA, SINGLEARROW, DOUBLEARROW;
terminal String VARIABLE, TYPE, PRIMITIVE;

terminal Integer INTLIT, INTBOX;

non terminal Program Program;
non terminal Bind Bind;
non terminal LambdaForm LambdaForm;

non terminal Expression Expression, CaseExpression, LetBinding;
non terminal Application Application;

non terminal Alternatives Alternatives;
non terminal List<Alternative> NonDefaultAlternatives;
non terminal Alternative Alternative;
non terminal DefaultAlternative DefaultAlternative;

non terminal Atom Atom;
non terminal Variable Variable;
non terminal Constructor Constructor;
non terminal Literal Literal;

non terminal List<Atom> Atoms, AtomList;
non terminal List<Bind> Bindings;
non terminal List<Variable> Variables;

non terminal Boolean LetIsRecursive, LambdaArrow;
non terminal Epsilon;
non terminal CaseArrow;

start with Program;


CaseArrow ::= SINGLEARROW
            | DOUBLEARROW:anchor
                                                {: new WarningMessage.DoubleCaseArrow(position(anchorleft, anchorright))
                                                    .emitWarning();
                                                :}
            ;

LambdaArrow ::= SINGLEARROW
                                                {: RESULT = false; :}
              | DOUBLEARROW
                                                {: RESULT = true; :}
              ;

LetIsRecursive ::= LET
                                                {: RESULT = false; :}
                 | LETREC
                                                {: RESULT = true; :}
                 ;

Epsilon ::=  ; // Empty symbol



Program ::= Bindings:bindings
                                                {: RESULT = new Program(position(bindingsleft, bindingsright), bindings); :}
          ;

Bindings ::= Bind:head Bindings:tail
                                                {: RESULT = cons(head, tail); :}
           | Bind:head
                                                {: RESULT = cons(head, nil()); :}
           ;

Bind ::= VARIABLE:var EQ:anchor LambdaForm:lambda
                                                {: RESULT = new Bind(position(anchorleft, anchorright), new Variable(position(varleft, varright), var), lambda); :}
       ;

//
//
//

LambdaForm ::= LAMBDA:anchor LEFT Variables:free RIGHT Variables:args LambdaArrow:arrow Expression:expr
                                                {: RESULT = new LambdaForm(position(anchorleft, anchorright), free, arrow, args, expr); :}
             | LAMBDA:anchor Variables:args LambdaArrow:arrow Expression:expr
                                                {: RESULT = new LambdaForm(position(anchorleft, anchorright), null, arrow, args, expr); :}
             ;

//
//
//

Expression ::= CaseExpression:expr
                                                {: RESULT = expr; :}
             | LetBinding:expr
                                                {: RESULT = expr; :}
             | Application:expr
                                                {: RESULT = expr; :}
             | Literal:literal
                                                {: RESULT = literal; :}
             | INTBOX:box
                                                {: final Position position = position(boxleft, boxright);
                                                   if (!isExtensionEnabled(Extensions.ALLOW_NONPRIMITIVE_NUMBERS)) {
                                                       throw new ErrorMessage.BoxedLiteral(position);
                                                   }
                                                   final Constructor constructor = new Constructor(position, "Int#");
                                                   final Literal literal = new Literal(position, box);
                                                   RESULT = new ConstructorApplication(position, constructor, List.of(literal)); :}
             ;

LetBinding ::= LetIsRecursive:let Bindings:binds IN Expression:expr
                                                {: RESULT = new LetBinding(position(letleft, letright), let, binds, expr); :}
             ;

CaseExpression ::= MATCH:anchor Expression:expr LEFT Alternatives:alternatives RIGHT
                                                {: RESULT = new CaseExpression(position(anchorleft, anchorright), expr, alternatives); :}
                 ;

//
//
//

Application ::= Variable:function Atoms:args
                                                {: RESULT = new FunctionApplication(position(functionleft, functionright), function, args); :}
              | Constructor:constr Atoms:args
                                                {: RESULT = new ConstructorApplication(position(constrleft, constrright), constr, args); :}
              | PRIMITIVE:op Atoms:args
                                                {: RESULT = new PrimitiveApplication(position(opleft, opright), op, args); :}
              ;

//
//
//

Alternatives ::= NonDefaultAlternatives:alts DefaultAlternative:def
                                                {: RESULT = new Alternatives(position(altsleft, altsright), alts, def); :}
               ;

NonDefaultAlternatives ::= CASE:anchor Alternative:head NonDefaultAlternatives:tail
                                                {: RESULT = cons(head, tail); :}
                         | Epsilon
                                                {: RESULT = nil(); :}
                         ;

Alternative ::= Constructor:constr Atoms:args CaseArrow Expression:expr
                                                {: RESULT = new AlgebraicAlternative(position(constrleft, constrright), constr, args, expr); :}
              | Literal:literal CaseArrow Expression:expr
                                                {: RESULT = new PrimitiveAlternative(position(literalleft, literalright), literal, expr); :}
              | INTBOX:literal CaseArrow Expression:expr
                                                {: new WarningMessage.AmbiguousBoxedInteger(position(literalleft, literalright)).emitWarning();
                                                   RESULT =  new PrimitiveAlternative(position(literalleft, literalright),
                                                        new Literal(position(literalleft, literalright), literal), expr);
                                                :}
              ;
DefaultAlternative ::= DEFAULT:anchor CaseArrow Expression:expr
                                                {: RESULT = new DefaultFallthroughAlternative(position(anchorleft, anchorright), expr); :}
                     | Variable:binder CaseArrow Expression:expr
                                                {: RESULT = new DefaultBindingAlternative(position(binderleft, binderright), binder, expr); :}
                     | Epsilon:anchor
                                                {: RESULT = new NoAlternative(position(anchorleft, anchorright)); :}
                     ;

//
//
//

Variables ::= Variable:head Variables:tail
                                                {: RESULT = cons(head, tail); :}
            | Epsilon
                                                {: RESULT = nil(); :}
            ;

Atoms ::= LEFT AtomList:list RIGHT
                                                {: RESULT = list; :}
        ;

AtomList ::= Atom:head AtomList:tail
                                                {: RESULT = cons(head, tail); :}
           | Epsilon
                                                {: RESULT = nil(); :}
           ;

Atom ::= Variable:variable
                                                {: RESULT = variable; :}
       | Literal:literal
                                                {: RESULT = literal; :}
       ;

Variable ::= VARIABLE:variable
                                                {: RESULT = new Variable(position(variableleft, variableright), variable); :}
           ;

Constructor ::= TYPE:type
                                                {: RESULT = new Constructor(position(typeleft, typeright), type); :}
              ;

Literal ::= INTLIT:literal
                                                {: RESULT = new Literal(position(literalleft,literalright), literal); :}
          ;

